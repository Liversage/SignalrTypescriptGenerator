using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using CommandLine;
using RazorEngine;
using RazorEngine.Templating;
using SignalrTypescriptGenerator.Models;
using Encoding = System.Text.Encoding;

namespace SignalrTypescriptGenerator {

  class Program {

    static int Main(string[] args) {
      if (AppDomain.CurrentDomain.IsDefaultAppDomain())
        return RunInNewAppDomainToAllowRazorEngineToCleanup(args);

      try {
        return Parser.Default.ParseArguments<CommandLineOptions>(args)
          .MapResult(
            options => {
              Run(options);
              return 0;
            },
            errors => 1
          );
      }
      catch (Exception ex) {
        Console.WriteLine(ex);
        return 1;
      }
    }

    static int RunInNewAppDomainToAllowRazorEngineToCleanup(string[] args) {
      var appDomain = AppDomain.CreateDomain("RazorEngine", null, AppDomain.CurrentDomain.SetupInformation);
      var exitCode = appDomain.ExecuteAssembly(Assembly.GetExecutingAssembly().Location, args);
      AppDomain.Unload(appDomain);
      return exitCode;
    }

    static void Run(CommandLineOptions commandLineOptions) {
      var signalrHelper = new SignalrHubinator(commandLineOptions.AssemblyPath);

      var model = new TypesModel {
        TypeInfos = signalrHelper.GetInterfaces()
      };

      Engine.Razor.AddTemplate("interface", ReadEmbeddedFile("Templates.Interface.cshtml"));
      Engine.Razor.AddTemplate("enum", ReadEmbeddedFile("Templates.Enum.cshtml"));
      var template = ReadEmbeddedFile("Templates.Template.cshtml");
      var outputText = Engine.Razor.RunCompile(template, "templateKey", model.GetType(), model);

      if (!string.IsNullOrEmpty(commandLineOptions.OutFile)) {
        if (!FileHasChanged(commandLineOptions.OutFile, outputText))
          return;
        outputText = model.LastGenerated + Environment.NewLine + outputText;
        File.WriteAllText(commandLineOptions.OutFile, outputText);
      }
      else {
        outputText = model.LastGenerated + Environment.NewLine + outputText;
        Console.WriteLine(outputText);
      }
    }

    static bool FileHasChanged(string filename, string contents) {
      var currentContents = File.Exists(filename) ? File.ReadAllText(filename) : string.Empty;

      // Remove the timestamp
      var startIndex = currentContents.IndexOf("// Autogenerated", StringComparison.Ordinal);
      if (startIndex > -1) {
        var endIndex = currentContents.IndexOf(Environment.NewLine, startIndex, StringComparison.Ordinal);
        if (endIndex > startIndex)
          currentContents = currentContents.Substring(endIndex + Environment.NewLine.Length);
      }

      var currentHash = GetMd5(currentContents);
      var newHash = GetMd5(contents);
      Console.WriteLine($"[SignalrTypescriptGenerator] Existing MD5 for {filename}: {currentHash}");
      Console.WriteLine($"[SignalrTypescriptGenerator] New MD5: {newHash}");

      var hashesAreDifferent = currentHash != newHash;
      Console.WriteLine($"[SignalrTypescriptGenerator] (content is {(hashesAreDifferent ? "different - generating new file" : "the same - skipping file generation.")})");

      return hashesAreDifferent;
    }

    static string GetMd5(string contents) {
      using (var md5 = MD5.Create())
        using (var memoryStream = new MemoryStream(Encoding.UTF8.GetBytes(contents))) {
          var hash = md5.ComputeHash(memoryStream);
          return hash.Aggregate(new StringBuilder(), (sb, b) => sb.Append(b.ToString("x2"))).ToString();
        }
    }

    static string ReadEmbeddedFile(string file) {
      var resourcePath = $"{typeof(Program).Namespace}.{file}";

      var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourcePath);
      if (stream == null)
        throw new InvalidOperationException($"Unable to find '{resourcePath}' as an embedded resource");

      string textContent;
      using (var reader = new StreamReader(stream))
        textContent = reader.ReadToEnd();

      return textContent;
    }

  }

}