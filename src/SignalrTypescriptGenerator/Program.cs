using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using CommandLine;
using RazorEngine;
using RazorEngine.Templating;
using SignalrTypescriptGenerator.Models;

namespace SignalrTypescriptGenerator
{
	class Program
	{
		static void Main(string[] args)
		{
			try
			{
				Parser.Default.ParseArguments<CommandLineOptions>(args)
					.MapResult(options =>
					{
						Run(options);
						return 0;
					},
					errors => 
					{
						Environment.Exit(1);
						return 1;
					});
			}
			catch (Exception e)
			{
				Console.WriteLine(e);
				Environment.Exit(1);
			}
		}

		static void Run(CommandLineOptions commandLineOptions)
		{
			var signalrHelper = new SignalrHubinator(commandLineOptions.AssemblyPath);

			var model = new TypesModel();
			model.Hubs = signalrHelper.GetHubs();
			model.ServiceContracts = signalrHelper.GetServiceContracts();
			model.Clients = signalrHelper.GetClients();
			model.DataContracts = signalrHelper.GetDataContracts();
			model.Enums = signalrHelper.GetEnums();

			string template = ReadEmbeddedFile("template.cshtml");
			string outputText = Engine.Razor.RunCompile(template, "templateKey", null, model);

			if (!string.IsNullOrEmpty(commandLineOptions.OutFile))
			{
				if (FileHasChanged(commandLineOptions.OutFile, outputText))
				{
					outputText = model.LastGenerated + Environment.NewLine + outputText;
					File.WriteAllText(commandLineOptions.OutFile, outputText);
				}
			}
			else
			{
				outputText = model.LastGenerated + Environment.NewLine + outputText;
				Console.WriteLine(outputText);
			}
		}

		static bool FileHasChanged(string filename, string contents)
		{
			string currentContents = File.ReadAllText(filename);

			// Remove the timestamp
			int startIndex = currentContents.IndexOf("// Autogenerated", StringComparison.Ordinal);
			if (startIndex > -1)
			{
				int endIndex = currentContents.IndexOf(Environment.NewLine, startIndex, StringComparison.Ordinal);
				if (endIndex > startIndex)
				{
					currentContents = currentContents.Substring(endIndex + Environment.NewLine.Length);
				}
			}

			string currentHash = GetMd5(currentContents);
			string newHash = GetMd5(contents);
			Console.WriteLine("[SignalrTypescriptGenerator] Existing MD5 for {0}: {1}", filename, currentHash);
			Console.WriteLine("[SignalrTypescriptGenerator] New MD5: {0}", newHash);

			bool hashesAreDifferent = (currentHash != newHash);
			Console.WriteLine("[SignalrTypescriptGenerator] (content is {0})", hashesAreDifferent ? "different - generating new file" : "the same - skipping file generation.");

			return hashesAreDifferent;
		}

		static string GetMd5(string contents)
		{
			using (var md5 = MD5.Create())
			{
				using (var memoryStream = new MemoryStream())
				{
					using (var writer = new StreamWriter(memoryStream))
					{
						writer.Write(contents);
						memoryStream.Position = 0;

						byte[] hash = md5.ComputeHash(memoryStream);
						StringBuilder stringBuilder = new StringBuilder();

						// Put it into nice hex format
						foreach (byte b in hash)
						{
							stringBuilder.AppendFormat("{0:x2}", b);
						}

						return stringBuilder.ToString();
					}
				}
			}
		}

		static string ReadEmbeddedFile(string file)
		{
			string resourcePath = string.Format("{0}.{1}", typeof(Program).Namespace, file);

			Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourcePath);
			if (stream == null)
				throw new InvalidOperationException(string.Format("Unable to find '{0}' as an embedded resource", resourcePath));

			string textContent = "";
			using (StreamReader reader = new StreamReader(stream))
			{
				textContent = reader.ReadToEnd();
			}

			return textContent;
		}
	}
}
